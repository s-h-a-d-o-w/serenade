import { fileURLToPath as O } from "url";
import { dirname as E } from "path";
import { createRequire as x } from "module";
import P from "chokidar";
import f from "serenade-driver";
import T from "fast-glob";
import _ from "os";
import B from "path";
import I from "ws";
const M = O(import.meta.url), z = E(M), k = x(import.meta.url);
let l = {}, b = {}, h = {}, S = (e) => {
};
const w = B.join(_.homedir(), ".serenade", "scripts");
let y, g = {};
const u = (e, t, n, d) => {
  typeof e == "string" && (e = [e]);
  for (let r = 0; r < e.length; r++)
    e[r] === "intellij" && (e[r] = "jetbrains");
  return typeof t == "string" && (t = [t]), typeof n == "string" && (n = [n]), typeof d == "string" && (d = [d]), {
    command: (r, o, a, c) => {
      const i = Math.random().toString();
      return l[i] = {
        id: i,
        applications: e,
        languages: t,
        extensions: n,
        urls: d,
        templated: r,
        autoExecute: a && a.autoExecute,
        chainable: a && a.chainable,
        callback: o,
        disabled: !!c
      }, i;
    },
    disable: (r) => {
      typeof r == "string" && (r = [r]);
      for (const o of r)
        l[o] && (l[o].disabled = !0), h[o] && (h[o].disabled = !0), b[o] && (b[o].disabled = !0);
      v();
    },
    enable: (r) => {
      typeof r == "string" && (r = [r]);
      for (const o of r)
        l[o] && (l[o].disabled = !1), h[o] && (h[o].disabled = !1), b[o] && (b[o].disabled = !1);
      v();
    },
    hint: (r, o) => {
      const a = Math.random().toString();
      b[a] = {
        id: a,
        applications: e,
        languages: t,
        extensions: n,
        urls: d,
        hint: r,
        disabled: !!o
      };
    },
    key: (r, o, a, c, i) => {
      const s = Math.random().toString();
      return l[s] = {
        id: s,
        applications: e,
        languages: t,
        extensions: n,
        urls: d,
        templated: r,
        autoExecute: c && c.autoExecute,
        chainable: c && c.chainable,
        callback: (j) => {
          j.pressKey(o, a);
        },
        disabled: !!i
      }, s;
    },
    pronounce: (r, o, a) => {
      const c = Math.random().toString();
      return h[c] = {
        id: c,
        applications: e,
        languages: t,
        extensions: n,
        urls: d,
        before: r,
        after: o,
        disabled: !!a
      }, c;
    },
    snippet: (r, o, a, c, i) => {
      const s = Math.random().toString();
      return a && c === void 0 && i === void 0 && (a.formatting && (a = a.formatting), a.snippetType && (c = a.snippetType)), l[s] = {
        id: s,
        applications: e,
        languages: t,
        extensions: n,
        urls: d,
        templated: r,
        generated: o,
        options: a,
        snippetType: c,
        disabled: !!i
      }, s;
    },
    text: (r, o, a, c) => {
      const i = Math.random().toString();
      return l[i] = {
        id: i,
        applications: e,
        languages: t,
        extensions: n,
        urls: d,
        templated: r,
        autoExecute: a && a.autoExecute,
        chainable: a && a.chainable,
        callback: (s) => {
          s.typeText(o);
        },
        disabled: !!c
      }, i;
    }
  };
};
function q(e, t) {
  let n = null;
  return ((...d) => {
    n && clearTimeout(n), n = setTimeout(() => e(...d), t);
  });
}
const F = (e) => {
  m("domBlur", { query: e });
}, J = (e) => {
  m("domClick", { query: e });
}, L = (e) => {
  m("domCopy", { query: e });
}, N = (e) => {
  m("domFocus", { query: e });
}, R = (e) => {
  m("domScroll", { query: e });
}, p = (e) => {
  m("evaluateInPlugin", {
    command: e
  });
}, C = async () => {
  l = {};
  try {
    const e = await T([`${w.replace(/\\/g, "/")}/**/*.js`], { dot: !0, followSymbolicLinks: !0, ignore: ["**/node_modules/**", "**/.git/**"] });
    let t = !1;
    for (const n of e)
      try {
        const d = k.resolve(n);
        delete k.cache[d], k(d);
      } catch (d) {
        t = !0, console.error(d), m("error", { error: d.stack });
      }
    t || (m("error", { error: "" }), v());
  } catch (e) {
    console.error(e), m("error", { error: e.stack });
    return;
  }
}, A = async (e) => (m("sendText", { text: e }), new Promise((t) => {
  g[e] = t;
})), m = (e, t) => {
  !y || y.readyState != 1 || y.send(
    JSON.stringify({
      message: e,
      data: t
    })
  );
}, v = () => {
  m("customCommands", {
    commands: Object.values(l).filter((e) => !e.disabled),
    hints: Object.values(b).filter((e) => !e.disabled),
    words: Object.values(h).filter((e) => !e.disabled)
  });
}, K = {
  app: (e) => u(e, [], [], []),
  global: () => u([], [], [], []),
  language: (e) => u([], e, [], []),
  extension: (e) => u([], [], e, []),
  scope: (e, t) => u(e, t, [], []),
  url: (e, t) => (t || (t = ["chrome", "edge"]), u(t, [], [], e)),
  onContextChanged: (e) => {
    S = e;
  }
}, U = () => {
  global.serenade = K, f.focus = f.focusApplication, f.domBlur = F, f.domClick = J, f.domCopy = L, f.domFocus = N, f.domScroll = R, f.evaluateInPlugin = p, f.runCommand = A, y = new I("ws://localhost:17373"), y.on("message", async (e) => {
    const t = JSON.parse(typeof e == "string" ? e : e.toString());
    t.message == "execute" ? (Object.keys(l).includes(t.data.id) && await l[t.data.id].callback(f, t.data.matches), g = {}) : t.message == "reload" ? C() : t.message == "keepalive" ? m("keepalive", {}) : t.message == "callback" ? Object.keys(g).includes(t.data.transcript) && g[t.data.transcript]() : t.message == "contextChanged" && S && S(t.data);
  }), y.on("open", () => {
    C();
  }), P.watch(w, { ignoreInitial: !0 }).on("all", q(C, 500));
};
try {
  U();
} catch (e) {
  console.log(e);
}
